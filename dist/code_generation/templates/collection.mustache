import ky from "ky";
import { encode_search_params, Response, Response_Multiple } from "./utils/utils.js";
import { Collection, Bare_Document, Document_Array, _Base_Document, _With_Children, _With_Array } from "./root_types.js"

{{#child_collections}}
import { Collection_{{built_collection}} } from "{{ built_collection_path }}"
{{/child_collections}}

{{types}}

export class Collection_{{my_built_collection}} extends Collection {
    constructor(path: string[], get_auth: () => Promise<any>) {
        super(path, get_auth, "{{collection_id}}", "{{collection_name_plural}}");
    }

    
    async query(query: {{type_query}}): Promise<{{type_return}}[]>{
        try {
            let result = await ky.get(this.path.join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
                searchParams: encode_search_params(query)
            }).json() as Response_Multiple<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    async post(document: {{type_post}}): Promise<{{type_return}}>{
        try {
            let result = await ky.post(this.path.join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
                json: document
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    document(document_id: string) {
        let path = this.path;
        let get_auth = this.get_auth;
        let collection_id = this.collection_id;
        let collection_name_plural = this.collection_name_plural;
        return new Document_{{my_built_collection}}(path, collection_id, document_id, collection_name_plural, get_auth);
    }
}

class Document_{{my_built_collection}} extends Bare_Document implements _Base_Document{{#has_subcollections}}, _With_Children{{/has_subcollections}}{{#has_array_children}}, _With_Array{{/has_array_children}} {
    constructor(path: string[], collection_id: string, document_id: string, collection_name_plural: string, get_auth: () => Promise<any>) {
        super(path, collection_id, document_id, collection_name_plural, get_auth);
    }

    async get(): Promise<{{type_return}}>{
        try {
            let result = await ky.get([...this.path, this.document_id].join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    async put(update: {{type_put}}): Promise<{{type_return}}>{
        try {
            let result = await ky.put([...this.path, this.document_id].join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
                json: update
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }
    
    async remove(): Promise<{{type_return}}>{
        try {
            let result = await ky.delete([...this.path, this.document_id].join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    {{#has_subcollections}}
    {{#child_collections}}
    collection(collection_id: "{{collection_id}}"): Collection_{{built_collection}};
    {{/child_collections}}
    collection(collection_id: string) {
        switch(collection_id) {
            {{#child_collections}}
            case "{{collection_id}}":
                return new Collection_{{built_collection}}([...this.path, this.document_id, "{{collection_id}}"], this.get_auth);
            {{/child_collections}}
            default:
                throw new Error(`Api does not have the collection ${collection_id}`)
        }
    }
    {{/has_subcollections}}

    {{#has_array_children}}
    {{#array_children}}
    array(key: "{{array_name}}"): Collection_{{my_built_collection}}_Array_{{array_name}};
    {{/array_children}}
    array(key: string) {
        switch(key) {
            {{#array_children}}
            case "{{array_name}}":
                return new Collection_{{my_built_collection}}_Array_{{array_name}}([...this.path, this.document_id, "{{array_name}}"], this.document_id, this.get_auth);
            {{/array_children}}
            default:
                throw new Error(`Collection ${this.collection_id} does not have an array at the key ${key}`)
        }
    }
    {{/has_array_children}}
}

{{#array_children}}
{{array_type_put_definition}}
{{array_type_post_definition}}

export class Collection_{{my_built_collection}}_Array_{{array_name}} extends Document_Array {

    constructor(path: string[], document_id: string, get_auth: () => Promise<any>) {
        super(path, get_auth, "{{collection_id}}", "{{collection_name_plural}}", document_id, "{{array_name}}")
    }

    async push(document: {{type_array_child_post}}): Promise<{{type_return}}>{
        try {
            let result = await ky.post(this.path.join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
                json: document
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    async replace(document: {{type_array_child_put}}): Promise<{{type_return}}>{
        try {
            let result = await ky.put([...this.path, document._id].join('/'), {
                headers: {
                    authorization: await this.get_auth()
                },
                json: document
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }

    async delete(document_id: string): Promise<{{type_return}}>{
        try {
            let result = await ky.delete([...this.path, document_id].join('/'), {
                headers: {
                    authorization: await this.get_auth()
                }
            }).json() as Response<{{type_return}}>;
            return result.data;
        } catch(err){
            return Promise.reject(err)
        }
    }
}
{{/array_children}}